# solving the Euler Problems
import numpy as np
from math import sqrt
import time

start_time = time.time()



# Question 1
# If we list all the natural numbers below 10 that are multiples of 3 or 5,
# we get 3, 5, 6 and 9. The sum of these multiples is 23.
# Find the sum of all the multiples of 3 or 5 below 1000.

multiples = []
sum = 0
for i in range(1, 1000):
    if i % 3 == 0 or i % 5 == 0:
        sum += i
print('Question 1 =', sum)  # 233168

# Question 2
# Each new term in the Fibonacci sequence is generated by adding the previous
# two terms. By starting with 1 and 2, the first 10 terms will be:
# 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
# By considering the terms in the Fibonacci sequence whose values do not
# exceed four million, find the sum of the even-valued terms.

first = 1
second = 2
fib = 3
total = 2

while fib < 4000000:
    fib = first + second
    if fib % 2 == 0:
        total += fib
    first = second
    second = fib

print('Question 2 =', total)  # 4613732

# The prime factors of 13195 are 5, 7, 13 and 29.
# What is the largest prime factor of the number 600851475143


n = 600851475143
i = 2

while i * i < n:
    while n % i == 0:
        n = n / i
    i = i + 1

print('Question 3 =', int(n))  # 6857


# A palindromic number reads the same both ways. The largest palindrome
# made from the product of two 2-digit numbers is 9009 = 91 x 99.
# Find the largest palindrome made from the product of two 3-digit numbers.


def palindrome(a, b):
    """check to see if two numbers are palindromic"""
    c = a * b
    d = str(c)
    d = d[::-1]

    return c == int(d)


largest_found = 0
largest_a = 0
largest_b = 0

for a in range(999, 900, -1):
    b = 999
    found = False
    while found == False:
        found = palindrome(a, b)
        b -= 1

    if largest_found < (a * (b + 1)):
        largest_a = a
        largest_b = b + 1
        largest_found = largest_a * largest_b

print('Question 4 =', largest_found,
      '(', largest_a, largest_b, ')')  # 906609 ( 993 913 )

# 2520 is the smallest number that can be divided by each of the
# numbers from 1 to 10 without any remainder.
# What is the smallest positive number that is evenly divisible
# by all of the numbers from 1 to 20?

divisible = False
start_num = 2520
step = 20


def check_divisible(num):
    check_list = [11, 13, 14, 16, 17, 18, 19, 20]
    for i in check_list:
        if num % i != 0:
            return False
    return True


# while not divisible:
#     divisible = check_divisible(start_num)
#    start_num += step

print('Question 5 =', start_num - step)  # 232792560

# The sum of the squares of the first ten natural numbers is,
# 12 + 22 + ... + 10^2 = 385
# The square of the sum of the first ten natural numbers is,
# (1 + 2 + ... + 10)^2 = 552 = 3025
# Hence the difference between the sum of the squares of the first
# ten natural numbers and the square of the sum is 3025 - 385 = 2640.
# Find the difference between the sum of the squares of the
# first one hundred natural numbers and the square of the sum.

alist = np.arange(1, 101, 1)

# sum of squares
a = alist ** 2
a = np.sum(a)

# sqare of sum
b = np.sum(alist)
b = b ** 2

print('Question 6 =', b - a)  # 25164150

# By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13,
# we can see that the 6th prime is 13.
# What is the 10 001st prime number?

prime_list = [2]
num = 3

while len(prime_list) < 10001:
    is_prime = True
    for i in range(2, int(sqrt(num)) + 1):
        if num % i == 0:
            is_prime = False
            break

    if is_prime:
        prime_list.append(num)

    num += 1

print('Question 7 =', prime_list[-1:])  # 104743


# The four adjacent digits in the 1000-digit number that have the
# greatest product are 9 x 9 x 8 x 9 = 5832.
# Find the thirteen adjacent digits in the 1000-digit number that
# have the greatest product. What is the value of this product?

digits = '7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450'

start = 0
end = 13
largest = 0

for i in range(len(digits) + 1):
    dig_str = digits[start:end]
    total = 1
    for dig in dig_str:
        total *= int(dig)
    start += 1
    end += 1
    if total > largest:
        largest = total

print('Question 8 =', largest)  # 23514624000


# A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,
#
# a2 + b2 = c2
# For example, 3^22 + 4^2 = 9 + 16 = 25 = 5^2.
#
# There exists exactly one Pythagorean triplet for which a + b + c = 1000.
# Find the product abc.


def pythag(a, b, c):
    if a ** 2 + b ** 2 == c ** 2:
        return True
    return False

a = [x for x in range(1, 1000)]

for num in a:
    for dig in range(num, 1000 - num):
        for i in range(dig, 1000 - dig):
            if num + dig + i == 1000:
                if pythag(num, dig, i):
                    print(num, dig, i)
                    print("Question 9 =: {}".format(num * dig * i))
                    exit(1)


print("Program took %s seconds to run." % (time.time() - start_time))
